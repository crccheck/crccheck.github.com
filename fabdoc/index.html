<div id="module-fabric.context_managers" class="section">
<span id="context-managers"></span><h1>Context Managers<a title="Permalink to this headline" href="#module-fabric.context_managers" class="headerlink">¶</a></h1>
<p>Context managers for use with the <tt class="docutils literal"><span class="pre">with</span></tt> statement.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When using Python 2.5, you will need to start your fabfile
with <tt class="docutils literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">with_statement</span></tt> in order to make use of
the <tt class="docutils literal"><span class="pre">with</span></tt> statement (which is a regular, non <tt class="docutils literal"><span class="pre">__future__</span></tt> feature of
Python 2.6+.)</p>
</div>
<dl class="function">
<dt id="fabric.context_managers.cd">
<tt class="descclassname">fabric.context_managers.</tt><tt class="descname">cd</tt><big>(</big><em>path</em><big>)</big><a title="Permalink to this definition" href="#fabric.context_managers.cd" class="headerlink">¶</a></dt>
<dd><p>Context manager that keeps directory state when calling operations.</p>
<p>Any calls to <tt class="xref py py-obj docutils literal"><span class="pre">run</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">sudo</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>, or <tt class="xref py py-obj docutils literal"><span class="pre">put</span></tt> within the wrapped block will
implicitly have a string similar to <tt class="docutils literal"><span class="pre">"cd</span> <span class="pre">&lt;path&gt;</span> <span class="pre">&amp;&amp;</span> <span class="pre">"</span></tt> prefixed in order
to give the sense that there is actually statefulness involved.  <a title="fabric.context_managers.cd" href="#fabric.context_managers.cd" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt></a> only
affects the remote paths for <tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt> and <tt class="xref py py-obj docutils literal"><span class="pre">put</span></tt> &ndash; local paths are untouched.</p>
<p>Because use of <a title="fabric.context_managers.cd" href="#fabric.context_managers.cd" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt></a> affects all such invocations, any code making use of
those operations, such as much of the <tt class="docutils literal"><span class="pre">contrib</span></tt> section, will also be
affected by use of <a title="fabric.context_managers.cd" href="#fabric.context_managers.cd" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt></a>.</p>
<p>Like the actual ‘cd’ shell builtin, <a title="fabric.context_managers.cd" href="#fabric.context_managers.cd" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt></a> may be called with relative paths
(keep in mind that your default starting directory is your remote user’s
<tt class="docutils literal"><span class="pre">$HOME</span></tt>) and may be nested as well.</p>
<p>Below is a “normal” attempt at using the shell ‘cd’, which doesn’t work due
to how shell-less SSH connections are implemented &ndash; state is <strong>not</strong> kept
between invocations of <tt class="xref py py-obj docutils literal"><span class="pre">run</span></tt> or <tt class="xref py py-obj docutils literal"><span class="pre">sudo</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">run</span><span class="p">(</span><span class="s">'cd /var/www'</span><span class="p">)</span>
<span class="n">run</span><span class="p">(</span><span class="s">'ls'</span><span class="p">)</span>
</pre></div>
</div>
<p>The above snippet will list the contents of the remote user’s <tt class="docutils literal"><span class="pre">$HOME</span></tt>
instead of <tt class="docutils literal"><span class="pre">/var/www</span></tt>. With <a title="fabric.context_managers.cd" href="#fabric.context_managers.cd" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt></a>, however, it will work as expected:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="s">'/var/www'</span><span class="p">):</span>
    <span class="n">run</span><span class="p">(</span><span class="s">'ls'</span><span class="p">)</span> <span class="c"># Turns into "cd /var/www &amp;&amp; ls"</span>
</pre></div>
</div>
<p>Finally, a demonstration (see inline comments) of nesting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="s">'/var/www'</span><span class="p">):</span>
    <span class="n">run</span><span class="p">(</span><span class="s">'ls'</span><span class="p">)</span> <span class="c"># cd /var/www &amp;&amp; ls</span>
    <span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="s">'website1'</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s">'ls'</span><span class="p">)</span> <span class="c"># cd /var/www/website1 &amp;&amp; ls</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This context manager is currently implemented by appending to (and, as
always, restoring afterwards) the current value of an environment
variable, <tt class="docutils literal"><span class="pre">env.cwd</span></tt>. However, this implementation may change in the
future, so we do not recommend manually altering <tt class="docutils literal"><span class="pre">env.cwd</span></tt> &ndash; only
the <em>behavior</em> of <a title="fabric.context_managers.cd" href="#fabric.context_managers.cd" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt></a> will have any guarantee of backwards
compatibility.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space characters will be escaped automatically to make dealing with
such directory names easier.</p>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 1.0: </span>Applies to <tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt> and <tt class="xref py py-obj docutils literal"><span class="pre">put</span></tt> in addition to the command-running
operations.</p>
</dd></dl>

<dl class="function">
<dt id="fabric.context_managers.hide">
<tt class="descclassname">fabric.context_managers.</tt><tt class="descname">hide</tt><big>(</big><em>*groups</em><big>)</big><a title="Permalink to this definition" href="#fabric.context_managers.hide" class="headerlink">¶</a></dt>
<dd><p>Context manager for setting the given output <tt class="docutils literal"><span class="pre">groups</span></tt> to False.</p>
<p><tt class="docutils literal"><span class="pre">groups</span></tt> must be one or more strings naming the output groups defined in
<tt class="xref py py-obj docutils literal"><span class="pre">output</span></tt>. The given groups will be set to False for the
duration of the enclosed block, and restored to their previous value
afterwards.</p>
<p>For example, to hide the “[hostname] run:” status lines, as well as
preventing printout of stdout and stderr, one might use <a title="fabric.context_managers.hide" href="#fabric.context_managers.hide" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">hide</span></tt></a> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_task</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">hide</span><span class="p">(</span><span class="s">'running'</span><span class="p">,</span> <span class="s">'stdout'</span><span class="p">,</span> <span class="s">'stderr'</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s">'ls /var/www'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="fabric.context_managers.lcd">
<tt class="descclassname">fabric.context_managers.</tt><tt class="descname">lcd</tt><big>(</big><em>path</em><big>)</big><a title="Permalink to this definition" href="#fabric.context_managers.lcd" class="headerlink">¶</a></dt>
<dd><p>Context manager for updating local current working directory.</p>
<p>This context manager is identical to <a title="fabric.context_managers.cd" href="#fabric.context_managers.cd" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt></a>, except
that it changes a different env var (<tt class="xref py py-obj docutils literal"><span class="pre">lcwd</span></tt>, instead of <tt class="xref py py-obj docutils literal"><span class="pre">cwd</span></tt>) and thus
only affects the invocation of <a title="fabric.operations.local" href="operations.html#fabric.operations.local" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">local</span></tt></a> and the local
arguments to <a title="fabric.operations.get" href="operations.html#fabric.operations.get" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt></a>/<a title="fabric.operations.put" href="operations.html#fabric.operations.put" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">put</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 1.0.</span></p>
</dd></dl>

<dl class="function">
<dt id="fabric.context_managers.path">
<tt class="descclassname">fabric.context_managers.</tt><tt class="descname">path</tt><big>(</big><em>path</em>, <em>behavior='append'</em><big>)</big><a title="Permalink to this definition" href="#fabric.context_managers.path" class="headerlink">¶</a></dt>
<dd><p>Append the given <tt class="docutils literal"><span class="pre">path</span></tt> to the PATH used to execute any wrapped commands.</p>
<p>Any calls to <tt class="xref py py-obj docutils literal"><span class="pre">run</span></tt> or <tt class="xref py py-obj docutils literal"><span class="pre">sudo</span></tt> within the wrapped block will implicitly have
a string similar to <tt class="docutils literal"><span class="pre">"PATH=$PATH:&lt;path&gt;</span> <span class="pre">"</span></tt> prepended before the given
command.</p>
<p>You may customize the behavior of <a title="fabric.context_managers.path" href="#fabric.context_managers.path" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">path</span></tt></a> by specifying the optional
<tt class="docutils literal"><span class="pre">behavior</span></tt> keyword argument, as follows:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'append'</span></tt>: append given path to the current <tt class="docutils literal"><span class="pre">$PATH</span></tt>, e.g.
<tt class="docutils literal"><span class="pre">PATH=$PATH:&lt;path&gt;</span></tt>. This is the default behavior.</li>
<li><tt class="docutils literal"><span class="pre">'prepend'</span></tt>: prepend given path to the current <tt class="docutils literal"><span class="pre">$PATH</span></tt>, e.g.
<tt class="docutils literal"><span class="pre">PATH=&lt;path&gt;:$PATH</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">'replace'</span></tt>: ignore previous value of <tt class="docutils literal"><span class="pre">$PATH</span></tt> altogether, e.g.
<tt class="docutils literal"><span class="pre">PATH=&lt;path&gt;</span></tt>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This context manager is currently implemented by modifying (and, as
always, restoring afterwards) the current value of environment
variables, <tt class="docutils literal"><span class="pre">env.path</span></tt> and <tt class="docutils literal"><span class="pre">env.path_behavior</span></tt>. However, this
implementation may change in the future, so we do not recommend
manually altering them directly.</p>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 1.0.</span></p>
</dd></dl>

<dl class="function">
<dt id="fabric.context_managers.prefix">
<tt class="descclassname">fabric.context_managers.</tt><tt class="descname">prefix</tt><big>(</big><em>command</em><big>)</big><a title="Permalink to this definition" href="#fabric.context_managers.prefix" class="headerlink">¶</a></dt>
<dd><p>Prefix all wrapped <tt class="xref py py-obj docutils literal"><span class="pre">run</span></tt>/<tt class="xref py py-obj docutils literal"><span class="pre">sudo</span></tt> commands with given command plus <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt>.</p>
<p>This is nearly identical to <tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt>, except that nested
invocations append to a list of command strings instead of modifying a
single string.</p>
<p>Most of the time, you’ll want to be using this alongside a shell script
which alters shell state, such as ones which export or alter shell
environment variables.</p>
<p>For example, one of the most common uses of this tool is with the
<tt class="docutils literal"><span class="pre">workon</span></tt> command from <a href="http://www.doughellmann.com/projects/virtualenvwrapper/" class="reference external">virtualenvwrapper</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">prefix</span><span class="p">(</span><span class="s">'workon myvenv'</span><span class="p">):</span>
    <span class="n">run</span><span class="p">(</span><span class="s">'./manage.py syncdb'</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above snippet, the actual shell command run would be this:</p>
<div class="highlight-python"><pre>$ workon myvenv &amp;&amp; ./manage.py syncdb</pre>
</div>
<p>This context manager is compatible with <a title="fabric.context_managers.cd" href="#fabric.context_managers.cd" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">cd</span></tt></a>, so
if your virtualenv doesn’t <tt class="docutils literal"><span class="pre">cd</span></tt> in its <tt class="docutils literal"><span class="pre">postactivate</span></tt> script, you could
do the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="s">'/path/to/app'</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">prefix</span><span class="p">(</span><span class="s">'workon myvenv'</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s">'./manage.py syncdb'</span><span class="p">)</span>
        <span class="n">run</span><span class="p">(</span><span class="s">'./manage.py loaddata myfixture'</span><span class="p">)</span>
</pre></div>
</div>
<p>Which would result in executions like so:</p>
<div class="highlight-python"><pre>$ cd /path/to/app &amp;&amp; workon myvenv &amp;&amp; ./manage.py syncdb
$ cd /path/to/app &amp;&amp; workon myvenv &amp;&amp; ./manage.py loaddata myfixture</pre>
</div>
<p>Finally, as alluded to near the beginning,
<a title="fabric.context_managers.prefix" href="#fabric.context_managers.prefix" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">prefix</span></tt></a> may be nested if desired, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">prefix</span><span class="p">(</span><span class="s">'workon myenv'</span><span class="p">):</span>
    <span class="n">run</span><span class="p">(</span><span class="s">'ls'</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">prefix</span><span class="p">(</span><span class="s">'source /some/script'</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s">'touch a_file'</span><span class="p">)</span>
</pre></div>
</div>
<p>The result:</p>
<div class="highlight-python"><pre>$ workon myenv &amp;&amp; ls
$ workon myenv &amp;&amp; source /some/script &amp;&amp; touch a_file</pre>
</div>
<p>Contrived, but hopefully illustrative.</p>
</dd></dl>

<dl class="function">
<dt id="fabric.context_managers.settings">
<tt class="descclassname">fabric.context_managers.</tt><tt class="descname">settings</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a title="Permalink to this definition" href="#fabric.context_managers.settings" class="headerlink">¶</a></dt>
<dd><p>Nest context managers and/or override <tt class="docutils literal"><span class="pre">env</span></tt> variables.</p>
<p><a title="fabric.context_managers.settings" href="#fabric.context_managers.settings" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">settings</span></tt></a> serves two purposes:</p>
<ul class="simple">
<li>Most usefully, it allows temporary overriding/updating of <tt class="docutils literal"><span class="pre">env</span></tt> with
any provided keyword arguments, e.g. <tt class="docutils literal"><span class="pre">with</span> <span class="pre">settings(user='foo'):</span></tt>.
Original values, if any, will be restored once the <tt class="docutils literal"><span class="pre">with</span></tt> block closes.</li>
<li>In addition, it will use <a href="http://docs.python.org/library/contextlib.html#contextlib.nested" class="reference external">contextlib.nested</a> to nest any given
non-keyword arguments, which should be other context managers, e.g.
<tt class="docutils literal"><span class="pre">with</span> <span class="pre">settings(hide('stderr'),</span> <span class="pre">show('stdout')):</span></tt>.</li>
</ul>
<p>These behaviors may be specified at the same time if desired. An example
will hopefully illustrate why this is considered useful:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_task</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">settings</span><span class="p">(</span>
        <span class="n">hide</span><span class="p">(</span><span class="s">'warnings'</span><span class="p">,</span> <span class="s">'running'</span><span class="p">,</span> <span class="s">'stdout'</span><span class="p">,</span> <span class="s">'stderr'</span><span class="p">),</span>
        <span class="n">warn_only</span><span class="o">=</span><span class="bp">True</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">run</span><span class="p">(</span><span class="s">'ls /etc/lsb-release'</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">'Ubuntu'</span>
        <span class="k">elif</span> <span class="n">run</span><span class="p">(</span><span class="s">'ls /etc/redhat-release'</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">'RedHat'</span>
</pre></div>
</div>
<p>The above task executes a <tt class="xref py py-obj docutils literal"><span class="pre">run</span></tt> statement, but will warn instead of
aborting if the <tt class="docutils literal"><span class="pre">ls</span></tt> fails, and all output &ndash; including the warning
itself &ndash; is prevented from printing to the user. The end result, in this
scenario, is a completely silent task that allows the caller to figure out
what type of system the remote host is, without incurring the handful of
output that would normally occur.</p>
<p>Thus, <a title="fabric.context_managers.settings" href="#fabric.context_managers.settings" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">settings</span></tt></a> may be used to set any combination of environment
variables in tandem with hiding (or showing) specific levels of output, or
in tandem with any other piece of Fabric functionality implemented as a
context manager.</p>
</dd></dl>

<dl class="function">
<dt id="fabric.context_managers.show">
<tt class="descclassname">fabric.context_managers.</tt><tt class="descname">show</tt><big>(</big><em>*groups</em><big>)</big><a title="Permalink to this definition" href="#fabric.context_managers.show" class="headerlink">¶</a></dt>
<dd><p>Context manager for setting the given output <tt class="docutils literal"><span class="pre">groups</span></tt> to True.</p>
<p><tt class="docutils literal"><span class="pre">groups</span></tt> must be one or more strings naming the output groups defined in
<tt class="xref py py-obj docutils literal"><span class="pre">output</span></tt>. The given groups will be set to True for the
duration of the enclosed block, and restored to their previous value
afterwards.</p>
<p>For example, to turn on debug output (which is typically off by default):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_task</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">show</span><span class="p">(</span><span class="s">'debug'</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s">'ls /var/www'</span><span class="p">)</span>
</pre></div>
</div>
<p>As almost all output groups are displayed by default, <a title="fabric.context_managers.show" href="#fabric.context_managers.show" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">show</span></tt></a> is most useful
for turning on the normally-hidden <tt class="docutils literal"><span class="pre">debug</span></tt> group, or when you know or
suspect that code calling your own code is trying to hide output with
<a title="fabric.context_managers.hide" href="#fabric.context_managers.hide" class="reference internal"><tt class="xref py py-obj docutils literal"><span class="pre">hide</span></tt></a>.</p>
</dd></dl>

</div>
